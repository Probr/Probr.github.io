"use strict";angular.module("probrSiteApp",["ngCookies","ngResource","ngSanitize","btford.socket-io","ui.router","ui.bootstrap","hc.marked"]).config(["$stateProvider","$urlRouterProvider","$locationProvider",function(a,b,c){b.otherwise("overview"),c.html5Mode(!1)}]),angular.module("probrSiteApp").controller("DocumentationCtrl",["$scope","$http",function(a,b){}]).controller("DocumentationCoreCtrl",["$scope","$http",function(a,b){var c={count:2,next:null,previous:null};a.jwtObj={username:"",password:""},a.deviceObj={},a.deviceObj.GET="Device Object",a.deviceObj["GET/LIST"]=angular.extend(c,{results:["Device Object #1","Device Object #2"]}),a.statusObj={},a.statusObj.GET="Status Object",a.statusObj["GET/LIST"]=angular.extend(c,{results:["Status Object #1","Status Object #2"]}),a.commandObj={},a.commandObj.GET="Command Object",a.commandObj["GET/LIST"]=angular.extend(c,{results:["Command Object #1","Command Object #2"]}),a.templateObj={},a.templateObj.GET="Template Object",a.templateObj["GET/LIST"]=angular.extend(c,{results:["Template Object #1","Template Object #2"]}),a.deviceCaptureObj={},a.deviceStatusObj={},a.deviceCommandObj={}}]).controller("DocumentationAnalysisCtrl",["$scope","$http",function(a,b){var c={_id:"566ee9bf50dbe11300703759",multiplier:1.0129218750000004,noOfCircles:3,area:.67,location:{coordinates:[8.549603298636361,47.41450563092935],type:"Point"},time:"2015-11-16T15:40:00.000Z",mac_address:"--",tags:["seallab","odroid","demo"],derivedFrom:[{"long":8.54959,lat:47.414517,weightedSignal:-42,cnt:2},{"long":8.549587,lat:47.414482,weightedSignal:-46,cnt:2},{"long":8.54964025950721,lat:47.4144933237122,weightedSignal:-46,cnt:2}],__v:0},d={_id:"56a778211588c6000cf00350",mac_address_src:"--",time:"2016-01-26T13:43:59.890Z",tags:["seallab","odroid","demo"],capture_uuid:"8da797ef-f146-4dd2-9b9f-94d4a9919e12",inserted_at:"2016-01-26T13:44:01.469Z",mac_address_dst:"ffffffffffff",signal_strength:-78,location:{type:"Point",coordinates:[8.54959,47.414517]},fragment_number:0,sequence_number:3346,ssid:"eduroam"};a.deviceObj={},a.deviceObj["GET/LIST"]=["Device Object #1","Device Object #2"],a.locationObj={},a.locationObj["GET/LIST"]=[c,c],a.packetObj={},a.packetObj["GET/LIST"]=[d,d],a.sessionObj={},a.sessionObj["GET/LIST"]=[{_id:"56a777b940af3d5cb025ab2f",mac_address:"-",startTimestamp:"2015-11-16T15:42:42.496Z",endTimestamp:"2015-11-16T16:57:41.656Z",count:41,tags:["seallab","odroid","demo"],weightedSignalStrength:-49,duration:4499},{_id:"56a777b840af3d5cb0258d26",mac_address:"-",startTimestamp:"2015-11-16T15:40:45.439Z",endTimestamp:"2015-11-16T17:36:45.454Z",count:32,tags:["seallab","odroid","demo"],weightedSignalStrength:-49,duration:6960}],a.sessionReduceObj={},a.sessionReduceObj["GET/LIST"]=[{_id:"2016-01-17T13:40:00.000Z",value:2},{_id:"2016-01-17T13:45:00.000Z",value:2}]}]),angular.module("probrSiteApp").config(["$stateProvider",function(a){a.state("docs",{url:"/docs",templateUrl:"app/documentation/documentation.html",controller:"DocumentationCtrl"}).state("docs-core",{url:"/docs/core",templateUrl:"app/documentation/documentation-core.html",controller:"DocumentationCoreCtrl"}).state("docs-analysis",{url:"/docs/analysis",templateUrl:"app/documentation/documentation-analysis.html",controller:"DocumentationAnalysisCtrl"})}]),angular.module("probrSiteApp").controller("FaqCtrl",["$scope",function(a){a.message="Hello"}]),angular.module("probrSiteApp").config(["$stateProvider",function(a){a.state("faq",{url:"/faq",templateUrl:"app/faq/faq.html",controller:"FaqCtrl"})}]),angular.module("probrSiteApp").controller("InstallationCtrl",["$scope",function(a){}]).controller("InstallationCoreCtrl",["$scope",function(a){a.installation="docker"}]).controller("InstallationAnalysisCtrl",["$scope",function(a){a.installation="docker"}]),angular.module("probrSiteApp").config(["$stateProvider",function(a){a.state("installation",{url:"/installation",templateUrl:"app/installation/installation.html",controller:"InstallationCtrl"}).state("installation-core",{url:"/installation/core",templateUrl:"app/installation/installation-core.html",controller:"InstallationCoreCtrl"}).state("installation-analysis",{url:"/installation/analysis",templateUrl:"app/installation/installation-analysis.html",controller:"InstallationAnalysisCtrl"})}]),angular.module("probrSiteApp").controller("OverviewCtrl",["$scope",function(a){}]),angular.module("probrSiteApp").config(["$stateProvider",function(a){a.state("overview",{url:"/overview",templateUrl:"app/overview/overview.html",controller:"OverviewCtrl"})}]),angular.module("probrSiteApp").controller("UsageCtrl",["$scope",function(a){}]).controller("UsageCoreCtrl",["$scope",function(a){a.installation="docker"}]).controller("UsageAnalysisCtrl",["$scope",function(a){a.installation="docker"}]),angular.module("probrSiteApp").config(["$stateProvider",function(a){a.state("usage",{url:"/usage",templateUrl:"app/usage/usage.html",controller:"UsageCtrl"}).state("usage-core",{url:"/usage/core",templateUrl:"app/usage/usage-core.html",controller:"UsageCoreCtrl"}).state("usage-analysis",{url:"/usage/analysis",templateUrl:"app/usage/usage-analysis.html",controller:"UsageAnalysisCtrl"})}]),angular.module("probrSiteApp").controller("UsecaseCtrl",["$scope",function(a){}]),angular.module("probrSiteApp").config(["$stateProvider",function(a){a.state("usecase",{url:"/usecase",templateUrl:"app/usecase/usecase.html",controller:"UsecaseCtrl"})}]),angular.module("probrSiteApp").directive("restApi",function(){return{scope:{methods:"=",path:"=",payload:"=",name:"=",description:"="},templateUrl:"components/directives/restApi.html",link:function(a,b){a.maxLimit=300,a.limit=a.maxLimit,a.displayedMethod=a.methods[0],a["switch"]=function(b){a.displayedMethod=b},a.extendLimit=function(){a.limit<=a.maxLimit?a.limit=5e4:a.limit=a.maxLimit}}}}).filter("trimByMethod",function(){return function(a,b){return("POST"==b||"GET/LIST"==b)&&a.indexOf(":")>-1?a.substr(0,a.indexOf(":")):a}}),angular.module("probrSiteApp").directive("stickyNav",["$window",function(a){function b(b,c){function d(){!c.hasClass("controls-fixed")&&a.pageYOffset>g+f&&a.innerWidth>=1200?c.addClass("controls-fixed"):c.hasClass("controls-fixed")&&a.pageYOffset<=g+f&&a.innerWidth>=1200&&c.removeClass("controls-fixed")}var e=angular.element(a),f=c[0].clientHeight,g=0;b.$watch(function(){return c[0].getBoundingClientRect().top+a.pageYOffset},function(a,b){a===b||c.hasClass("controls-fixed")||(g=a)}),e.bind("resize",function(){c.removeClass("controls-fixed"),g=c[0].getBoundingClientRect().top+a.pageYOffset,d()}),e.bind("scroll",d)}return{scope:{},restrict:"A",link:b}}]),angular.module("probrSiteApp").filter("prettyJSON",function(){function a(a){return JSON?JSON.stringify(a,null,"  "):"your browser doesnt support JSON so cant pretty print"}return a}),angular.module("probrSiteApp").directive("footer",function(){return{templateUrl:"components/footer/footer.html",restrict:"E",link:function(a,b){b.addClass("footer")}}}),angular.module("probrSiteApp").factory("Modal",["$rootScope","$modal",function(a,b){function c(c,d){var e=a.$new();return c=c||{},d=d||"modal-default",angular.extend(e,c),b.open({templateUrl:"components/modal/modal.html",windowClass:d,scope:e})}return{confirm:{"delete":function(a){return a=a||angular.noop,function(){var b,d=Array.prototype.slice.call(arguments),e=d.shift();b=c({modal:{dismissable:!0,title:"Confirm Delete",html:"<p>Are you sure you want to delete <strong>"+e+"</strong> ?</p>",buttons:[{classes:"btn-danger",text:"Delete",click:function(a){b.close(a)}},{classes:"btn-default",text:"Cancel",click:function(a){b.dismiss(a)}}]}},"modal-danger"),b.result.then(function(b){a.apply(b,d)})}}}}}]),angular.module("probrSiteApp").controller("NavbarCtrl",["$scope","$location",function(a,b){a.isArray=angular.isArray,a.menu=[{title:"Getting Started",link:[{name:"probr-core",link:"installation-core"},{name:"probr-analysis",link:"installation-analysis"}]},{title:"Documentation",link:[{name:"probr-core",link:"docs-core"},{name:"probr-analysis",link:"docs-analysis"}]},{title:"Usage",link:[{name:"probr-core",link:"usage-core"},{name:"probr-analysis",link:"usage-analysis"}]},{title:"FAQ",link:"faq"},{title:"Usecase",link:"usecase"}],a.isCollapsed=!0,a.isActive=function(a){return a===b.path()},a.isActiveRoot=function(a){if(angular.isArray(a))return!1;a=a.toLowerCase();var c=b.path().split("/")[1];return a.slice(0,c.length)==c}}]),angular.module("probrSiteApp").directive("navbar",function(){return{templateUrl:"components/navbar/navbar.html",restrict:"E",controller:"NavbarCtrl"}}),angular.module("probrSiteApp").directive("particles",["$window",function(a){return{restrict:"A",link:function(b,c,d,e){a.particlesJS(d.id,{particles:{number:{value:40,density:{enable:!0,value_area:450}},color:{value:"#ffffff"},shape:{type:"circle",stroke:{width:0,color:"#000000"},polygon:{nb_sides:5}},opacity:{value:.5,random:!1,anim:{enable:!1,speed:1,opacity_min:.1,sync:!1}},size:{value:3,random:!0,anim:{enable:!1,speed:40,size_min:.1,sync:!1}},line_linked:{enable:!0,distance:150,color:"#ffffff",opacity:.4,width:1},move:{enable:!0,speed:.5,direction:"none",random:!1,straight:!1,out_mode:"out",bounce:!1,attract:{enable:!1,rotateX:600,rotateY:1200}}},interactivity:{detect_on:"canvas",events:{onhover:{enable:!1,mode:"bubble"},onclick:{enable:!0,mode:"push"},resize:!0},modes:{grab:{distance:400,line_linked:{opacity:1}},bubble:{distance:400,size:40,duration:2,opacity:8,speed:3},repulse:{distance:200,duration:.4},push:{particles_nb:4},remove:{particles_nb:2}}},retina_detect:!0})}}}]),angular.module("probrSiteApp").factory("socket",["socketFactory",function(a){var b=io("",{path:"/socket.io-client"}),c=a({ioSocket:b});return{socket:c,syncUpdates:function(a,b,d){d=d||angular.noop,c.on(a+":save",function(a){var c=_.find(b,{_id:a._id}),e=b.indexOf(c),f="created";c?(b.splice(e,1,a),f="updated"):b.push(a),d(f,a,b)}),c.on(a+":remove",function(a){var c="deleted";_.remove(b,{_id:a._id}),d(c,a,b)})},unsyncUpdates:function(a){c.removeAllListeners(a+":save"),c.removeAllListeners(a+":remove")}}}]),angular.module("probrSiteApp").run(["$templateCache",function(a){a.put("app/documentation/documentation-analysis.html",'<navbar></navbar><div class="container content"><div class=row><div class="col-lg-3 side-nav-col"><section sticky-nav><h1>Contents</h1><ul class="nav nav-pills nav-stacked"><li><a href=/#/docs/analysis#architecture>Architecture</a></li><li><a href=/#/docs/analysis#data-model>Data Model</a></li><li><a href=/#/docs/analysis#frontend>Front-End</a></li><li><a href=/#/docs/analysis#rest>REST API</a></li><h3>Async Workers</h3><li><a href=/#/docs/analysis#sessions-worker>Sessions</a></li><li><a href=/#/docs/analysis#locations-worker>Locations</a></li><li><a href=/#/docs/analysis#devices-worker>Devices</a></li></ul></section></div><div class=col-lg-9><h1>probr-analysis</h1><h2><a name=architecture>Architecture</a></h2><p>The diagram below shows the architecture of the probr-analysis application. Note that the database that serves as a storage and source for the packets is the same database that is fed by the <a href=/#/docs/core>probr-core system</a> .</p><img class="doc-img img-responsive" src="assets/images/architecture_analysis.bfc249d6.png"><p>probr-analysis is a multi-tiered web application. The frontend is a standard HTML5 and JavaScript web frontend. It provides the graphical user interface that allows to explore the data collected in the first step by probr-core. The backend is written in NodeJS and provides the REST API endpoints for the frontend. A very important part of probr-analysis are the workers. They asynchronously aggregate the raw packet data into more sophisticated data models such as sessions, locations, or devices.</p><h2><a name=data-model>Data Model</a></h2>The domain of probr-analysis deals with four types of entities: packets, devices, locations, and sessions. The packets are the main source of information in the system. They come from the probr-core sniffing component. The other three entity types are aggregated and calculated by our <a href=/#/docs/analysis#sessions-worker>workers</a>. The diagram below shows the main entities in probr-analysis:<p><img class="doc-img img-responsive" src="assets/images/data_model.645df465.png"></p><h2><a name=frontend>Front-End</a></h2><p>Optional URL Parameters (all apart from the Live View):</p><pre><code>startTimestamp: Start of the selected time range, UNIX timestamp<br>endTimestamp: End of the selected time range, UNIX timestamp<br>tags: the selected tag as a single string</code></pre><h3>Live View</h3><pre><code>/live</code></pre><ul><li>Displays incoming packets from the probr-core sniffers in real time.</li><li>Displays identified devices in the intervals: last five minutes, last hour, and last day.</li></ul><h3>Log View</h3><pre><code>/packets</code></pre><ul><li>Displays a log of all sniffed packets.</li><li>The user can restrict or filter the data by setting a tag and a date/time range in the navigation bar.</li></ul><h3>Utilization View</h3><pre><code>/utilization</code></pre><ul><li>Displays the utilization graph for the chosen tag and date/time range.</li><li>Displays the loyalty graph for the chosen tag and date/time range.</li><li>Displays the swimlane graph for the current data of the utilization graph.</li><li>The user can zoom within the swimlane graph and move around in the date/time range.</li></ul><h3>Location View</h3><pre><code>/heatmap</code></pre><ul><li>Displays an interactive map containing the locations as a heatmap.</li><li>The user can restrict or filter the data by setting a tag and a date/time range in the navigation bar.</li></ul><h3>Stats View</h3><pre><code>/devices</code></pre><ul><li>Displays a chart of the vendor statistics for the selected tag and time range.</li><li>Displays a ranking of vendors based on identified device count and percentage.</li><li>Displays statistics about MAC randomization in the identified device data.</li><li>The user can restrict or filter the data by setting a tag and a date/time range in the navigation bar.</li></ul><h3>Tracking View</h3><pre><code>/mac</code></pre><ul><li>The user can add named aliases for MAC addresses to be tracked.</li><li>The presence patterns of tracked aliases are displayed in a swimlane graph</li><li>The user can zoom within the swimlane graph and move around in the date/time range</li><li>The user can restrict or filter the data by setting a tag and a date/time range in the navigation bar.</li></ul><h2><a name=rest>REST API</a></h2><h3>Devices</h3><p><rest-api methods="[\'GET/LIST\']" payload=deviceObj path="\'/api/device/query?starTimestamp={timestamp}&endTimestamp={timestamp}&tags={tag}\'" description="\'Get devices identified in a certain time range and with a certain tag.\'"><!-- not used anymore in analysis\r\n                        <rest-api methods="[\'GET/LIST\']" , payload="deviceObj" path="\'/api/device/lastFive\'"\r\n                                  description="\'Get devices seen in the last 5 minutes.\'"></rest-api>\r\n                        <hr />\r\n                        <rest-api methods="[\'GET/LIST\']" , payload="deviceObj" path="\'/api/device/lastHour\'"\r\n                                  description="\'Get devices seen in the last hour.\'"></rest-api>\r\n                        <hr />\r\n                        <rest-api methods="[\'GET/LIST\']" , payload="deviceObj" path="\'/api/device/lastDay\'"\r\n                                  description="\'Get devices seen in the last hour.\'"></rest-api>\r\n                    --></p><h3>Locations</h3><p><rest-api methods="[\'GET/LIST\']" payload=locationObj path="\'/api/locations?query={URL-encoded MongoDB query object}\'" description="\'You can use arbitrary MongoDB query objects.\'"></p><h3>Sessions</h3><p><rest-api methods="[\'GET/LIST\']" payload=sessionObj path="\'/api/session?query={URL-encoded MongoDB query object}\'" description="\'You can use arbitrary MongoDB query objects.\'"><hr><rest-api methods="[\'GET/LIST\']" payload=sessionReduceObj path="\'/api/session/reduce?startTimestamp={timestamp}&endTimestamp={timestamp}&tags={tag}\'" description="\'Gets the aggregated session data for the utilization view, according to the passed timestamps and tag.\'"></p><h3>Packets</h3><p><rest-api methods="[\'GET/LIST\']" payload=packetObj path="\'/api/packets/count?query={URL-encoded MongoDB query object}\'" description="\'On this endpoint, you can choose what parameters you use. You can use arbitrary MongoDB query objects and can filter packets arbitrarily and also use MongoDB features like sorting.\'"></p><h2><a name=workers>Async workers</a></h2><p>In order to answer more sophisticated questions (see <a href=/#/usecase#questions>here</a>) in a timely manner, incremental preprocessing and aggregation of the raw packet data is required. The amount of raw packet data is too large to perform aggregation queries on demand (i.e., when the user requests some data). Therefore, probr-analysis employs a worker system that periodically runs asynchronous tasks in order to aggregate the information of interest in advance.</p><p>There are three worker tasks in probr-analysis:<ul><li>Session-Worker</li><li>Location-Worker</li><li>Device-Worker</li></ul></p><p>The worker tasks are encapsulated in a separate node app, which can be started independently from the rest of probr-analysis. You can find the code for the worker tasks <a href=https://github.com/probr/probr-analysis/tree/master/worker>here</a>. In the following, the computations that are conducted by the workers are explained.</p><h3><a name=sessions-worker>Sessions</a></h3><p>A session is defined as the time interval that a certain MAC address was present at a location monitored by our sniffing devices. Our definition of a MAC address being \'present\' is: The device with said MAC address is present if we have collected probes for it with less than 5 minutes in between. Let\'s look at an example:</p><img class="doc-img img-responsive" src="assets/images/sessions.85b26671.png"><p>Here, the packets #1 and #2 belong to the same session, because they are less than 5 minutes apart. The next packet, although from the same MAC address, does not belong to the same session because the inter-packet time is too large. Hence, packet #3 starts a new session on its own. A session that consists only of one packet (thus having a duration of 0) is not considered in our system. Depending on the use case, you might want to tweak the 5 minute session threshold and also decide to ignore sessions below a certain length.</p><p>In the actual implementation, the session aggregation task is implemented as a MapReduce algorithm. You can check out the corresponding code <a href=https://github.com/probr/probr-analysis/blob/master/worker/components/session/session.mapreduce.js>here</a>.</p><h3><a name=locations-worker>Locations</a></h3><p>How is it possible to compute geographical locations out of the sniffed probe requests/packets ? The fact that the probe requests contain the measured signal strength makes it possible to compute locations by <a href=https://en.wikipedia.org/wiki/Trilateration>trilateration</a>.</p><p>To employ trilateration, the user has to set a correct latitude and longitude for the sniffing devices when initially setting up the probr-core sniffing system. These will in turn assign their lat/lng location data to each of the packets they sniff. Now each packet contains a lat/lng location and a measured signal strength in dbM.</p><p>The first step the location task performs is to extract raw locations from the sniffed packets. This is accomplished through a MapReduce algorithm that runs directly on the MongoDB. The MapReduce algorithm first maps together all packets that were sniffed within the same minute and have the same source MAC address. Then it extracts location and signal strength for all packets in that minute/MAC address mapping. The raw loaction now links this array of lat/lng locations and signal strength values to a time and MAC address key. These objects are then stored in a raw locations collection.</p><p>Then the algorithm incrementally iterates over the raw locations and performs the actual trilateration. The following listing outlines the algorithm:</p><img class="doc-img img-responsive" src="assets/images/location_algorithm.befb4a90.png"><p>This process is visualized in the following animation:</p><img class="doc-img img-responsive" src="assets/images/gifs/location.22e0619a.gif"><h3><a name=devices-worker>Devices</a></h3><p>The device task runs on a regular interval and takes all packets into consideration that have been added to the system since the previous pass. On every pass, the device task goes through all packets and extracts unique MAC addresses. If the MAC address is already identified as a device by a previous pass of the task, only its last_seen property is updated to the timestamp of the packet. Otherwise, if the MAC address is not yet identified, the device task consults the <a href=http://standards-oui.ieee.org/oui.txt>IEEE IOU</a> database for MAC address vendor prefixes. By querying the database with the first three octets of the corresponding MAC address, we can gather information about the vendor of that device.</p></div></div></div><footer></footer>'),a.put("app/documentation/documentation-core.html","<navbar></navbar><div class=\"container content\"><div class=row><div class=\"col-lg-3 side-nav-col\"><section sticky-nav><h1>Contents</h1><ul class=\"nav nav-pills nav-stacked\"><li><a href=/#/docs/core#architecture>Architecture</a></li><li><a href=/#/docs/core#frontend>Front-End</a></li><li><a href=/#/docs/core#rest>REST API</a></li><h3>Customizing</h3><li><a href=/#/docs/core#handlers>Handlers</a></li></ul></section></div><div class=col-lg-9><h1>Documentation: probr-core</h1><h2><a name=architecture>Architecture</a></h2><p>The image below shows the architecture of probr-core. Also, the used technologies are indicated in the respective components.</p><img class=\"doc-img img-responsive\" src=assets/images/architecture_core.b3d9039d.png><p>probr-core is built mainly in Python as a Django web application. It serves a frontend for the user written in HTML 5 and AngularJS. Through the front end interface, the user can set up sniffing devices, enter sniffing commands, upload existing pcap files containing packets, and manage or check the status of the attached sniffing devices. The probr-core Django application uses a PostgreSQL database internally as a backend to store and manage the different sniffing devices, commands, statuses, and uploads.</p><p>The Django back-end component provides the REST API endpoints for the front end, and more importantly, also provides the REST API endpoints for the sniffing devices. Through those API endpoints the devices receive their commands to execute (e.g., start sniffing, start uploading packets, or any other unix command) and also report status data such as CPU load and memory usage on a regular basis. The sniffing devices upload the captured data via pcap files to the capture endpoint on the Django back-end. On receiving the pcap files, probr-core then feeds them to the Celery worker handlers which unpack each pcap file into an appropriate structure for the respective storage. Out of the box, probr-core has built-in handlers for MongoDB and InfluxDB, but it is designed to be easily extensible. Instructions on how to write handlers for the data storage systems of your choice can be found <a href=#/faq>here</a>.</p><h2><a name=frontend>Front-End</a></h2>The web frontend is the main component the user interacts with. It is written entirely in HTML5 and JavaScript (using AngularJS). It provides the following views:<h3>Devices View</h3><small><pre><code>/web/devices</code></pre></small><ul><li>Lets the user add new devices through the device wizard.</li><li>Lets the user see all registered devices and their status.</li><li>Lets the user open the device detail view of a device.</li><li>Allows deletion of devices from the probr system.</li><li>Allows bulk execution of a command on multiple devices</li></ul><h3>Devices Detail View</h3><small><pre><code>/web/device/{device-uuid}</code></pre></small><ul><li>Lets the user execute commands in the web terminal of a device</li><li>Allows to start sniffing and uploading packets from predefined command templates</li><li>Allows to update the device client code for probr.</li></ul><h3>Captures View</h3><small><pre><code>/web/captures</code></pre></small><ul><li>Allows to see the uploaded pcap files and download them</li><li>The user can upload pcap files by hand to integrate into the system.</li></ul><h2><a name=rest>REST API</a></h2><h3>Authentication</h3><p>Probr-core uses standard <a href=\"http://jwt.io/\" target=_blank>JSON Web Token Authentication</a> to enable protected REST-Endpoints being queried. Further information can be found in the documentation of the plugin developer <a href=\"http://getblimp.github.io/django-rest-framework-jwt/\" target=_blank>Django REST Framework JWT</a> as well as in their repository on <a href=https://github.com/GetBlimp/django-rest-framework-jwt target=_blank>Github</a>.</p><rest-api name=\"'Devices'\" methods=\"['GET', 'GET/LIST', 'POST', 'PUT', 'DELETE']\" payload=deviceObj path=\"'/api/device/:device-uuid'\"><rest-api name=\"'Statuses'\" methods=\"['GET/LIST']\" payload=statusObj path=\"'/api/statuses?device=device-uuid'\"><rest-api name=\"'Commands'\" methods=\"['GET','GET/LIST','POST','PUT']\" payload=commandObj path=\"'/api/commands/:command-uuid'\"><rest-api name=\"'Templates'\" methods=\"['GET','GET/LIST','POST','PUT']\" payload=templateObj path=\"'/api/commandtemplates/:commandtemplate-uuid'\"><h3><a name=rest-devices>Devices API</a></h3><p>The API endpoints starting with api-device/ are the ones that are accessed solely by the sniffing devices. These endpoints can only be accessed with a valid api-key which identifies a device. Every sniffing device receives an api-key when it is registered to probr-core through the device registration wizard in the web frontend. Registering a new device is only possible if the user is logged in via Django user administration/JWTAuth.</p><rest-api name=\"'Captures'\" methods=\"['POST']\" payload=deviceCaptureObj path=\"'/api-device/captures'\"><rest-api name=\"'Statuses'\" methods=\"['GET','POST']\" payload=deviceStatusObj path=\"'/api-device/statuses'\"><rest-api name=\"'Commands'\" methods=\"['GET','POST','PUT']\" payload=deviceCommandObj path=\"'/api-device/commands'\"><!--<h2><a name=\"handlers\">Handlers</a></h2>--><!--<p>--><!--</p>--></div></div></div><footer></footer>"),a.put("app/documentation/documentation.html",'<navbar></navbar><div class="container content"><h1>Documentation</h1><div class=row><div class=col-lg-6><h2><a ui-sref=docs-core>probr-core</a></h2></div><div class=col-lg-6><h2><a ui-sref=docs-analysis>probr-analysis</a></h2></div></div></div><footer></footer>'),a.put("app/faq/faq.html",'<navbar></navbar><div class="container content"><h1>Frequently Asked Questions</h1><div class=row><div class=col-lg-12><h2>Is there any paper describing Probr available?</h2><p>There is a current paper available, which an be downloaded in a PDF copy <a href=assets/files/probr-paper.pdf>here</a>.</p></div></div><div class=row><div class=col-lg-12><h2>Which devices are supported?</h2><p>Probr is designed to support devices that run a *NIX (Linux, Mac OS X, UNIX) operating system, operate a wireless interface that can be set to monitor mode, and also have access to the internet. The system was tested with:</p><ul><li><a href=http://www.hardkernel.com/main/products/prdt_info.php>ODROID C1</a> with Ubuntu</li><li><a href="https://www.raspberrypi.org/products/model-b/">Raspberry Pi B</a> with Raspbian</li><li><a href="http://www.tp-link.com/at/products/details/?model=TL-MR3020">TP-Link TL-MR3020</a> with OpenWRT</li><li>Mac OS X</li><li>Ubuntu 14.04</li></ul><p>However, Probr is not limited to these devices. Any device satisfying the following requirements can be used:</p><ul><li>(ba)sh shell</li><li>wget (with https support)</li><li>tcpdump</li></ul></div></div><div class=row><div class=col-lg-12><h2>Which databases are supported?</h2><p>Out-of-the box, Probr supports the following databases as a storage for sniffed packets:</p><ul><li><a href="https://www.mongodb.org/">MongoDB</a></li><li><a href="https://influxdb.com/">InfluxDB</a></li></ul><p>If you want to use any other database for your use case, you can easily extend Probr to do so, just by adding a handler. You can take the handlers for the existing databases as an example (<a href=https://github.com/probr/probr-core/blob/master/handlers/handlers.py>here</a>). Then, you need to add your handler to the config variable "PROBR_HANDLERS" in <a href=https://github.com/probr/probr-core/blob/master/probr/base_settings.py>here</a>.</p></div></div><div class=row><div class=col-lg-12><h2>Do I need to know how the WiFi protocol works, or how to write sniffing scripts?</h2><p>No! That\'s the beauty of it. Probr comes with predefined command templates for sniffing WiFi probe requests and uploading them to Probr\'s backend database, from where you can start with your own analyses.</p></div></div></div><footer></footer>'),a.put("app/installation/installation-analysis.html",'<navbar></navbar><div class="container content"><h1>Probr-Analysis: Installation</h1><div class=row><div class="col-xs-6 install-block"><a ng-click="installation = \'docker\'"><i class="icon-install icon-docker" ng-class="{ \'icon-active\': installation === \'docker\' }"></i></a></div><div class="col-xs-6 install-block" ng-click="installation == \'python\'"><a ng-click="installation = \'nodejs\'"><i class="icon-install icon-nodejs" ng-class="{ \'icon-active\': installation === \'nodejs\' }"></i></a></div></div><div class=row ng-show="installation ===\'docker\'"><h2>Requirements</h2><ul><li><a href="https://git-scm.org/">Git</a></li><li><a href="http://docker.com/" target=_blank>Docker</a></li><li><a href="https://docs.docker.com/compose/" target=_blank>Docker-Compose</a></li><li><a ui-sref=installation-core target=_blank>Running Docker-Compose of Probr-Core</a></li></ul><h2>Installation</h2><p>Clone the probr-analysis repository and head into its directory.</p><pre><code>git clone https://github.com/probr/probr-analysis.git && cd probr-analysis</code></pre><h2>Starting</h2><p>Now let docker-compose start your probr-core instance:</p><pre><code>docker-compose up -d</code></pre><p>This will start probr-analysis, automatically linking with your existing probr-core containers.</p></div><div class=row ng-show="installation ===\'nodejs\'"><h2><a id=user-content-technology class=anchor href=#technology aria-hidden=true><span class="octicon octicon-link"></span></a>Requirements</h2><p>To build and run the application you will need:</p><ul><li><a href="https://git-scm.org/">Git</a></li><li><a href="https://nodejs.org/en/">NodeJS version 0.10</a></li><li><a href="https://www.npmjs.com/">NPM</a></li><li><a href="http://bower.io/">Bower</a></li><li><a href="https://www.mongodb.org/">MongoDB</a></li><li><a href="http://redis.io/">Redis</a></li></ul><p>Also, to have the best user experience, including live modes and analysis, you should have a running set-up of probr-core, as described <a href=https://github.com/probr/probr-core>here</a>.</p><h2>Installation</h2><p>Clone the probr-analysis repository and head into its directory.</p><pre><code>git clone https://github.com/probr/probr-analysis.git && cd probr-analysis</code></pre><h2>Starting</h2><p>Make sure probr-core runs and collects data. First make sure your mongo deamon runs:</p><pre><code>mongod &amp;</code></pre><p>Also, start your redis server:</p><pre><code>redis-server &amp;</code></pre><p>After cloning the repo and going into the <code>probr-analysis</code> directory:</p><pre><code>npm install</code></pre><p>After the installation of the npm dependencies has finished, install the bower dependencies:</p><pre><code>bower install</code></pre><p>These steps will also install <a href="http://gruntjs.com/">Grunt</a>. Our project comes with preconfigured grunt tasks, so you can run:</p><pre><code>grunt build</code></pre><p>To start the application, run:</p><pre><code>grunt serve</code></pre><p>The application should now be reachable under <a href=http://localhost:9000>http://localhost:9000</a>.</p></div></div><footer></footer>'),
a.put("app/installation/installation-core.html",'<navbar></navbar><div class="container content"><h1>Probr-Core: Installation</h1><div class=row><div class="col-xs-4 install-block"><a ng-click="installation = \'docker\'"><i class="icon-install icon-docker" ng-class="{ \'icon-active\': installation === \'docker\' }"></i></a></div><div class="col-xs-4 install-block" ng-click="installation == \'vagrant\'"><a ng-class="{ \'svg-active\': installation === \'vagrant\'}" ng-click="installation = \'vagrant\'"><svg style="margin-top: 20px; height: 100px" viewbox="0 0 256 270" version=1.1 xmlns=http://www.w3.org/2000/svg xmlns:xlink=http://www.w3.org/1999/xlink preserveaspectratio="xMinYMin meet"><g><g><path d="M255.28,19.1658667 C253.437867,17.6554667 238.961067,9.89226667 238.961067,9.89226667 L223.5136,18.8672 L223.505067,18.8618667 L238.952533,9.888 L223.5104,0.6848 L223.505067,18.8618667 L207.394133,9.84426667 C207.394133,9.84426667 194.215467,17.5477333 187.816533,21.2405333 C179.762133,25.888 160.007467,37.6501333 160.007467,37.6501333 L160.007467,55.0197333 L143.733333,97.4197333 L143.733333,120.442667 L132.311467,127.109333 L127.7664,138.9984 L95.7386667,55.9136 L95.744,37.6928 L31.9146667,0.664533333 L0.0309333333,19.1210667 L0,19.1136 L0,37.8901333 L19.8837333,85.7813333 L31.9669333,92.8981333 L31.9776,114.738133 L79.8784,231.0816 L127.7504,258.477867 L127.7504,258.635733 L175.559467,230.9696 L255.4528,37.5082667 L255.28,19.1658667" fill-opacity=0.3></path><path d="M127.7856,258.498133 L79.8784,231.0816 L31.9776,114.738133 L31.9669333,92.8981333 L19.8837333,85.7813333 L0,37.8901333 L0,19.1136 L15.7333333,28.2869333 L15.7333333,46.7712 L31.9946667,56.208 L31.9968,37.616 L63.7685333,55.9989333 L65.3002667,74.1973333 L111.489067,194.088533 L143.588267,212.7872 L143.588267,249.454933 L127.7408,240.133333 L127.7856,258.498133" fill-opacity=0.3></path><path d="M95.7386667,55.9136 L127.7664,138.9984 L127.700267,184.7648 L111.466667,193.997867 L65.3002667,74.064 L63.7685333,55.9989333 L95.744,37.6928 L95.7386667,55.9136" fill-opacity=0.2></path><path d="M15.7333333,28.2869333 L15.7333333,46.7712 L31.9968,37.616 L15.7333333,28.2869333" fill-opacity=0.2></path><path d="M31.9946667,56.208 L31.9968,37.616 L15.7333333,46.7712 L31.9946667,56.208" fill-opacity=0.6></path><path d="M127.700267,184.7648 L143.710933,193.9264 L161.537067,149.169067 L175.265067,157.3376 L175.265067,114.442667 L179.6448,104.0864 L191.333333,110.9312 L191.333333,92.7978667 L175.421867,83.5530667 L191.421867,74.2645333 L175.688533,65.1978667 L175.646933,46.768 L160.007467,37.6501333 L160.007467,55.0197333 L143.733333,97.4197333 L143.733333,120.442667 L132.311467,127.109333 L127.7664,138.9984 L127.700267,184.7648" fill-opacity=0.3></path><path d="M127.480533,203.5008 L143.588267,212.7872 L143.508267,249.463467 L175.559467,230.9696 L255.4528,37.5082667 L255.28,19.1658667 L207.394133,46.768 L207.394133,83.5925333 L191.333333,92.7978667 L191.333333,110.9312 L179.6448,104.0864 L175.265067,114.442667 L175.265067,157.248 L153.0208,170.328533 L143.710933,193.9264 L127.480533,203.5008" fill-opacity=0.2></path><path d="M63.6672,74.3978667 L79.7333333,65.0645333 L79.7333333,83.5306667 L63.6672,74.3978667" fill-opacity=0.6></path><path d="M79.7333333,83.5306667 L95.6661333,92.5312 L95.6661333,74.3978667 L79.7333333,65.0645333 L79.7333333,83.5306667" fill-opacity=0.3></path><path d="M47.8453333,120.196267 L47.8453333,138.795733 L63.9317333,129.5392 L47.8453333,120.196267" fill-opacity=0.2></path><path d="M79.9882667,138.882133 L63.8453333,148.2816 L47.8453333,138.795733 L63.9317333,129.5392 L79.9882667,138.882133" fill-opacity=0.6></path><path d="M79.7706667,194.133333 L79.7706667,212.890667 L95.9402667,203.541333 L79.7706667,194.133333" fill-opacity=0.2></path><path d="M111.522133,230.8832 L127.809067,240.349867 L127.867733,221.298133 L111.522133,230.8832" fill-opacity=0.6></path><path d="M127.7504,258.635733 L127.809067,240.349867 L143.508267,249.463467 L127.7504,258.635733" fill-opacity=0.2></path><path d="M127.700267,184.7648 L111.466667,193.997867 L127.480533,203.5008 L143.710933,193.9264 L127.700267,184.7648" fill-opacity=0.6></path><path d="M207.394133,83.5925333 L207.394133,46.768 L191.540267,37.7429333 L191.540267,56.0896 L175.688533,65.1978667 L207.394133,83.5925333" fill-opacity=0.3></path><path d="M175.421867,83.5530667 L191.421867,74.2645333 L207.394133,83.5925333 L191.333333,92.7978667 L175.421867,83.5530667" fill-opacity=0.6></path><path d="M175.688533,65.1978667 L191.540267,56.0896 L191.540267,37.7429333 L175.646933,46.768 L175.688533,65.1978667" fill-opacity=0.2></path><path d="M223.505067,18.8629333 L223.5104,0.6848 L238.952533,9.888 L223.505067,18.8629333" fill-opacity=0.3></path><path d="M255.28,19.1658667 L207.394133,46.768 L191.540267,37.7429333 L175.646933,46.768 L160.007467,37.6501333 C160.007467,37.6501333 179.762133,25.888 187.816533,21.2405333 C194.215467,17.5477333 207.394133,9.84426667 207.394133,9.84426667 L223.5136,18.8672 L238.961067,9.89226667 C238.961067,9.89226667 253.437867,17.6554667 255.28,19.1658667 C250.923733,21.7109333 255.28,19.1658667 255.28,19.1658667" fill-opacity=0.6></path><path d="M95.744,37.6928 L63.7685333,55.9989333 L0.0309333333,19.1210667 L31.9146667,0.664533333 L95.744,37.6928" fill-opacity=0.6></path><path d="M239.204267,46.3477333 L239.204267,28.432 L223.624533,37.4218667 L239.204267,46.3477333" fill-opacity=0.3></path><path d="M191.979733,129.6384 L207.482667,120.744533 L207.482667,138.5824 L191.979733,129.6384" fill-opacity=0.3></path><path d="M159.582933,203.378133 L159.582933,221.8624 L175.7312,212.520533 L159.582933,203.378133" fill-opacity=0.6></path><path d="M175.831467,212.520533 L175.632,194.1856 L159.582933,203.378133 L175.831467,212.520533" fill-opacity=0.3></path></g></g></svg></a></div><div class="col-xs-4 install-block" ng-click="installation == \'python\'"><a ng-click="installation = \'python\'"><i class="icon-install icon-python" ng-class="{ \'icon-active\': installation === \'python\' }"></i></a></div></div><div class=row ng-show="installation ===\'docker\'"><h2>Requirements</h2><ul><li><a href="https://git-scm.org/">Git</a></li><li><a href="http://docker.com/" target=_blank>Docker</a></li><li><a href="https://docs.docker.com/compose/" target=_blank>Docker-Compose</a></li></ul><h2>Installation</h2><p>Clone the probr-analysis repository and head into its directory.</p><pre><code>git clone https://github.com/probr/probr-core.git && cd probr-core</code></pre><h2>Starting</h2><p>Now let docker-compose start your probr-core instance:</p><pre><code>docker-compose up -d</code></pre><p>This will setup a functioning probr-core installation, as well as MongoDB and InfluxDB and its corresponding handlers.</p><p>In order to have a login for probr-core, you have to set-up a superuser for the application:</p><pre><code>docker exec -ti probrcore_web_1 python manage.py createsuperuser</code></pre><p>Probr core is now running on localhost:8000 (or the IP of your docker-machine). Now you can log in to the probr-core web application and manage your devices or start sniffing.</p></div><div class=row ng-show="installation ===\'python\'"><h2>Requirements</h2><ul><li><a href="https://git-scm.org/">Git</a></li><li><a href="https://www.python.org/">Python 2.7.x</a>, <a href=https://pypi.python.org/pypi/pip>pip</a></li><li><a href="https://nodejs.org/">Node, npm</a> >= 0.12</li><li><a href="http://www.postgresql.org/">PostgreSQL</a></li><li><a href="https://www.mongodb.org/">MongoDB</a></li><li><a href="http://redis.io/">Redis</a></li></ul><h3>OS Specific</h3><ul><li>OSX: Command Line Tools to build packages. Installed with Xcode.</li><li>Ubuntu/Debian:<br>Python header files <code>apt-get install python-dev</code><br>Postgres header files <code>apt-get install libpq-dev</code></li></ul><h2>Installation</h2><p>Make sure all the requirements are installed. We highly recommended to use <a href="https://virtualenv.pypa.io/en/latest/">Virtualenv</a> to manage the python environment for probr-core. This way you won\'t get any conflicts with preinstalled python packages. To install virtualenv do</p><pre><code>pip install virtualenv</code></pre><p>Create a new folder and create inside a new virtual python environment</p><pre><code>mkdir probr cd probr<br>virtualenv .env_probr </code></pre><p>Activate the virtual python environment:</p><pre><code>source .env_probr/bin/activate</code></pre><p>Clone the probr-core repository and go into the repository directory</p><pre><code>git clone https://github.com/probr/probr-core.git && cd probr-core</code></pre><p>Add (and modify) settings</p><pre><code>cp probr/settings.example.py probr/settings.py</code></pre><p>Install the python dependencies of the project:</p><pre><code>pip install -r requirements.txt</code></pre><p>If you have troubles installing a certain package, make sure you have the required header files installed (see requirements)</p><p>Now, install the frontend and web dependencies using bower:</p><pre><code>npm install -g bower<br> bower install</code></pre><p>You\'re pretty much set to start probr-core at this moment. What is left to do is:</p><p>Create the DB tables:</p><pre><code>python manage.py migrate</code></pre><p>Create an admin user for the Django webproject:</p><pre><code>python manage.py createsuperuser</code></pre><h3>Starting</h3><p>Make sure the mongodb deamon is running:</p><pre><code>mongod &amp; </code></pre><p>Also, the redis-server must be running before you can use probr-core</p><pre><code>redis-server &amp;</code></pre><p>Finally, you\'re ready to start your probr-core server by running:</p><pre><code>python manage.py runserver</code></pre><p>In order for the data to be processed and entered into the database, you need to start the celery worker:</p><pre><code>celery worker -A probr</code></pre><p>And you can check it out by visiting</p><pre><code>http://localhost:8000</code></pre></div><div class=row ng-show="installation ===\'vagrant\'"><h2>Requirements</h2><ul><li><a href="https://git-scm.org/">Git</a></li><li><a href="https://www.vagrantup.com/">Vagrant</a></li></ul><h2>Installation</h2><p>Clone the probr-core repository</p><pre><code>git clone https://github.com/probr/probr-core.git && cd probr-core</code></pre><h2>Starting</h2><p>Start the Vagrant VM</p><pre><code>vagrant up</code></pre><p>Probr core is now running on 192.168.100.10:8000. Username and password for the admin user is admin/admin.</p><h2>Troubleshooting</h2><p>If you want to debug the worker or the web django app you can do by ssh\'ing into the VM</p><pre><code>vagrant ssh</code></pre><p>and attaching to the screen session of the worker or backend</p><pre><code>screen -r probrcoreworker</code></pre><pre><code>screen -r probrcoreweb</code></pre><p>To de-attach press Ctrl-A Ctrl-D. Check <a href="https://www.gnu.org/software/screen/manual/">the official documentation</a> of screen for further information.</p></div></div><footer></footer>'),a.put("app/installation/installation.html",'<navbar></navbar><div class="container content"><h1>Getting Started</h1><div class=row><a ui-sref=installation-core><div class="col-xs-6 install-block"><i class="icon-install fa fa-cogs"></i> <span>Core</span></div></a> <a ui-sref=installation-analysis><div class="col-xs-6 install-block"><i class="icon-install fa fa-flask"></i> <span>Analysis</span></div></a></div></div><footer></footer>'),a.put("app/overview/overview.html",'<navbar></navbar><div class=particles-bg id=particles particles><header class=hero-unit id=banner><div class=container><img src=assets/images/probrlogo_white.bf46dc4b.png><h4 class="lead centered">a generic wifi tracking system</h4></div></header></div><div class="container content" id=whatisprobr><h1>Welcome!</h1><p>Probr is a generic and distributed wifi-tracking system, designed and developed over the course of a master\'s project in the context of the <a href="http://www.fp7-flamingo.eu/">FP7 Project and NoE FLAMINGO</a> at the <a href=http://www.csg.uzh.ch>Communication Systems Group CSG</a> of the <a href=http://www.ifi.uzh.ch>Department of Informatics IfI</a> at the <a href=http://www.uzh.ch>University of Zurich UZH</a>. Its aim is to make it easier to conduct research projects in the domain of wireless sniffing (i.e., wireless tracking) by leveraging an existing platform for custom analyses. The project is split into two independent parts.</p><div class=row><div class=col-md-6><h2>Core</h2><p><a ui-sref=docs-core>probr-core</a> is a python-django based system for remote device administration. It allows to setup basic *NIX devices to use for various tasks, including but not limited to sniffing. It processes *.pcap files and stores their content in numerous databases. You can write your own handlers to adjust probr-core to your use case.</p></div><div class=col-md-6><h2>Analysis</h2><p><a ui-sref=docs-analysis>probr-analysis</a> is a NodeJS based frontend that visualizes core concepts of our analysis of collected probe requests. It allows to track individual devices using their MAC-Address, as well as monitor room utilization using an custom-made algorithm.</p></div></div><div class=row><div class=col-xs-6><div class="row no-margin-row"><div class="col-xs-4 no-padding"><a ui-sref=installation-core><button class="btn btn-primary btn-block">Getting Started</button></a></div><div class="col-xs-4 no-padding"><a ui-sref=docs-core><button class="btn btn-default btn-block">Documentation</button></a></div><div class="col-xs-4 no-padding"><a href=https://github.com/probr/probr-core target=_blank><button class="btn btn-default btn-block"><i class="fa fa-github"></i> Github</button></a></div></div></div><div class=col-xs-6><div class="row no-margin-row"><div class="col-xs-4 no-padding"><a ui-sref=installation-analysis><button class="btn btn-primary btn-block">Getting Started</button></a></div><div class="col-xs-4 no-padding"><a ui-sref=docs-analysis><button class="btn btn-default btn-block">Documentation</button></a></div><div class="col-xs-4 no-padding"><a href=https://github.com/probr/probr-analysis target=_blank><button class="btn btn-default btn-block"><i class="fa fa-github"></i> Github</button></a></div></div></div></div><h1>Motiviation</h1><p>Using probr-core gives you a headstart when building your own sniffing architecture. Data collection therefore is easy, and faulty devices can be remotely administrated. This allows you to concentrate on your actual research project instead of rebuilding the same system for different use cases over and over again.</p><p>probr-core can be used for the following purposes:</p><ul><li>Out-of-the-box WiFi sniffing and monitoring</li><li>Included templates to sniff on a wide range of devices, given tcpdump is installed</li><li>No knowledge about WiFi protocols required</li><li>Free to use and entirely open-source</li><li>Supports a range of different databases for storage, such as MongoDB or InfluxDB</li></ul><h1>How it works</h1><p>Probr follows a distributed architecture. The central component, called probr-core, serves as a management and storage server. First, all sniffing devices register themselves on the server such that they can be remotely managed. They are able to submit their sniffing-results (or result of any other given task) to the server which will process the received payload through a flexible handler-system.</p><p>The system is currently able to process *.pcap files and store its contents into a database of your choice. New database adapters can also be written easily and registered in probr-core.</p></div><footer></footer>'),a.put("app/usage/usage-analysis.html",'<navbar></navbar><div class="container content"><h1>Probr-Analysis: Usage Examples</h1><h2>Packet Log</h2>The animation below shows how you can browse the packets of a certain tag and time range in the log view.<p><img src=assets/images/gifs/logview.372331e5.gif alt=Logview. class="usage-gif img-responsive"></p><h2>Utilization View</h2>The animation below shows how you can explore the room utilization for a certain tag and time range.<p><img src=assets/images/gifs/utilizationview.f1661e7b.gif alt=Logview. class="usage-gif img-responsive"></p><h2>Tracking View</h2>The animation below shows how you can track certain MAC addresses/persons and filter by a certain tag and time range.<p><img src=assets/images/gifs/trackingview.c864e7dc.gif alt=Logview. class="usage-gif img-responsive"></p><h2>Stats View</h2>The animation below shows how you can check out device statistics over a certain tag and time range.<p><img src=assets/images/gifs/statsview.903e3c13.gif alt=Logview. class="usage-gif img-responsive"></p></div><footer></footer>'),a.put("app/usage/usage-core.html",'<navbar></navbar><div class="container content"><div class=row><div class=col-xs-12><h1>Probr-Core: Usage Examples</h1><p>Probr-Core has been developed with support of embedded devices in mind. The only dependencies a device has to fulfil are:</p><ul><li>ability to execute <a target=_blank href=http://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/html_node/Portable-Shell.html>POSIX compliant shell scripts</a></li><li>wget with POST (--post-data) support</li><li>sed with REGEX support</li></ul><p>This means a recent version of busybox covers all dependencies. The Probr-Core daemon script has been tested on the following platforms:</p><ul><li>DD-WRT</li><li>OpenWRT</li><li>Ubuntu</li><li>Mac OS</li><li>Raspbian</li></ul><h1>Using a Raspberry Pi as Sniffing Device</h1><p>The Raspberry Pi is a perfect match for Probr-Core. It is a cheap, small and powerful computer that covers all requirements. This tutorial shows you how to setup your own Raspberry Pi without OS to the point it can sniff packets. Raspbian has been selected as the OS of choice, but considering the very basic dependencies every Raspberry Pi OS can be used.</p><h3>Installing Raspbian</h3><p>Start by downloading Raspbian from <a target=_blank href="https://www.raspberrypi.org/downloads/raspbian/">here</a>. Once you have the image file, use one of the following guides (depending on your OS) to setup the SD card and install the OS.</p><ul><li><a target=_blank href=https://www.raspberrypi.org/documentation/installation/installing-images/linux.md>Linux</a></li><li><a target=_blank href=https://www.raspberrypi.org/documentation/installation/installing-images/mac.md>MacOS</a></li><li><a target=_blank href=https://www.raspberrypi.org/documentation/installation/installing-images/windows.md>Windows</a></li></ul><h3>SSHing to the freshly installed Raspberry</h3><p>The next step is to SSH to your freshly setup raspberry. This will be the last time you need a direct SSH connection, so make it count. In Raspbian the default username/password combination is pi/raspberry. After you connected successfully do a \'sudo su\' (this will ask you for the password, the default is \'raspberry\') to gain root access. You are now ready to go to your Probr-Core installation and add a new device.</p><h3>Add your new device on Probr-Core</h3><p>The gif below shows how you can use the device wizard to add a sniffing device. The terminal on the right is a ssh connection to the device which shall be set up.</p><p><img src=assets/images/gifs/add_device_wizard.871a3050.gif alt="Adding a device." class="usage-gif img-responsive"></p><p>As you can see in the animation after copy/pasting the snippet to your device\'s root terminal, the device appears automagically in the web interface. From now on you can place your device wherever you want. As long as it has internet it can be controlled and monitored through Probr-Core, no port forwarding needed.</p><p><small>Note: The daemon script you installed by copy/pasting the snippet above will install itself as a @reboot cronjob. Furthermore every command executed from the Probr-Core interface will have root privileges. It is highly recommended to secure your server connections with HTTPS and strong passwords.</small></p><h3>Starting sniffing WiFi Packets</h3><p>Now that you can executed commands from the Probr-Core web interface, things start to get interesting. If you want to start WiFi packet collection (sniffing) the first thing you need to do is identify your WiFi network interface, the easiest way to achieve this is with a simple \'ifconfig\'. Our WiFi interface is called \'wlan0\'. Once identified you can start sniffing with the following script:</p><pre>\r\nsudo apt-get update\r\nsudo apt-get install -y tcpdump\r\nifconfig wlan0 down\r\niwconfig wlan0 mode monitor\r\niwconfig wlan0 channel 6\r\nifconfig wlan0 up\r\nmkdir -p captures\r\ntcpdump -e -ni wlan0 -s 0 -w captures/capture-%s.pcap -G 5 type mgt subtype probe-req</pre><p>The script installs tcpdump without user interaction, sets the interface into monitor mode and collects/stores probe requests to captures/capture-*.pcap</p><p>The next step is to move these distributed capture files to a central place. We do this by watching the capture folder and uploading those pcaps to the server:</p><pre>\r\napt-get install -y inotify-tools\r\n# Upload existing and future pcaps\r\n\r\n# Make sure output folder exists\r\nmkdir -p captures\r\n\r\n# Upload Existing\r\nfor file in captures/*.pcap\r\ndo\r\n    post_file \'/api-device/device-captures/\' "$file" && rm "$file"\r\ndone\r\n\r\n# Upload future pcaps (blocking)\r\ninotifywait -m captures/ -e close_write -e move |\r\n    while read path action file; do\r\n        post_capture "$file" && rm "captures/$file"\r\n    done</pre><p>The script installs inotify-tools without user interaction and watches the folder \'captures\'. Whenever a new file is created this file is uploaded. After uploading those pcaps the handlers will process them and we can analyse them in Probr-Analysis.</p><p>Note: Probr-Core comes preshipped with some command templates, the examples above are two of them.</p></div></div><div class=row><div class=col-xs-12><h2>Uploading a pcap from a different source:</h2><p>If you want to perform historic analysis of WiFi captures and don\'t need a live stream of packets Probr-Core gives you the option to manually upload pcaps. The following script shows you how you can easily upload many pcaps with a simple drag and drop:</p><p><img src=assets/images/gifs/upload_pcap.09aeb29d.gif alt="Uploading a pcap by hand." class="usage-gif img-responsive"></p><p>After uploading those pcaps the handlers will process them and we can analyse them in Probr-Analysis.</p></div></div></div><footer></footer>'),a.put("app/usage/usage.html",'<navbar></navbar><div class="container content"><h1>Getting Started</h1><div class=row><a ui-sref=installation-core><div class="col-xs-6 install-block"><i class="icon-install fa fa-cogs"></i> <span>Core</span></div></a> <a ui-sref=installation-analysis><div class="col-xs-6 install-block"><i class="icon-install fa fa-flask"></i> <span>Analysis</span></div></a></div></div><footer></footer>'),a.put("app/usecase/usecase.html",'<navbar></navbar><div class="container content" id=whatisprobr><div class=row><div class="col-lg-3 side-nav-col"><section sticky-nav><h1>Contents</h1><ul class="nav nav-pills nav-stacked"><li><a href=/#/usecase#questions>Research Questions</a></li><li><a href=/#/usecase#utilization>Q1: Room Utilization</a></li><li><a href=/#/usecase#tracking>Q2: Tracking</a></li><li><a href=/#/usecase#devices>Q3: Device Statistics</a></li><li><a href=/#/usecase#discussion>Discussion</a></li></ul></section></div><div class=col-lg-9><h1>Use-Cases</h1><p>In order to evaluate the usability of the probr system, the system was tested with a specific use case. The test run took place at a university meeting room (around 35 square meters area), where a scientific project meeting of 20 to 25 persons took place for two consecutive days. We will call this use case \'acelab\' (after the room it took place in).</p><p>During the meeting, we set up 6 sniffing devices to collect WiFi probe requests. The devices used for sniffing were <a href="http://www.hardkernel.com/main/products/prdt_info.php?g_code=G141578608433">Odroid C1</a> devices with the standard Odroid <a href="http://www.hardkernel.com/main/products/prdt_info.php?g_code=G141630348024">WiFi Module 4</a>.</p><h2><a name=questions>Research Questions</a></h2><p>The data collected during this meeting was used to evaluate the probr system and answer the following research questions:</p><p><b>Q1: Room Utilization</b></p><blockquote>Is it possible to determine room utilization, which means to determine the number of people in a room, using only passive wifi tracking?</blockquote><p><b>Q2: Tracking</b></p><blockquote>Can we track individual MAC addresses / persons ? What patterns are visible?</blockquote><p><b>Q3: Device Statistics</b></p><blockquote>What information can we get about the devices and vendors present during the examined period?</blockquote><p>In the following, we will examine each of those questions and discuss how probr answers them. The user navigation in the probr-analysis application pays attention to the use cases we had in mind. Under the \'analysis\' tab in the probr-analysis front-end, the user is presented with the tools to explore the collected data and answer the posed questions. In the navigation bar, the user can define the "use case" or "experiment" by setting a tag and a date/time range. The defined use case is then applied to all the analysis views. More info on the front-end can be found <a href="">here</a>.</p><h2><a name=utilization>Q1: Room Utilization</a></h2><p>After the development of probr-core and the first steps into the probr-analysis application, we noticed that just looking at the probe count or packet frequency is not sufficient to determine room utilization. Packets might end up being collected by our sniffing devices even if the device that originally sent out the packets just shortly walked by and did not even enter the monitored room at all. Therefore we had to think about a more sophisticated data model that we could construct from the packet data, in order to be able to say when someone has been present at a certain point in time and to determine how many MAC addresses or persons have been present at a given time t. This lead us to the definition of <a href="">sessions</a>, which proved to be a powerful tool for use cases and questions such as the one for Q1.</p><p>Under the \'utilization\' tab in the \'analysis\' part of the probr-analysis <a href="">front-end</a>, the utilization graph is displayed. It displays the number of concurrent sessions at each point in time.</p><img class="doc-img img-responsive" src="assets/images/utilizations.e8d055db.png"><p>The time axis granularity at which the concurrent session counts are computed is at 5 minute slots. This means, the bar chart produces a bar for every five minutes on the time ranges, where the height of the bar is equal to the number of concurrent sessions present at that time slot. So this graph shows us, how many unique MAC addresses or devices have been present at different times in a room (defined by the tag).</p><p>One can clearly identify a pattern in the utilization graph. In order to be able to evaluate the correctness and accuracy of probrs utilization results, we also recorded the real number of persons in the room during the acelab. The figure below compares both data sets:</p><img class="doc-img img-responsive" src="assets/images/utilizations_comparison.b0cc29d2.png"><p>The comparison shows that the utilization computed by the probr system is satisfying and fairly accurate. The breaks and starting or end times of the meeting days can be observed very clearly. It is important to note that the number of sessions will always be higher than the number of real persons at each point in time because one person potentially carries multiple devices (e.g., notebook and smartphone) which will result in two sessions at the same time for the same person. But nevertheless, the patterns are detected, and one can conclude that probr does a good job in assessing room utilization.</p><p>In addition to the utilization of a room equipped with sniffing devices, probr allows its users to also look at the geographical locations or positions of the sniffed packets and devices. The locations are computed with a triangulation-based approach, as shown <a href="">here</a>. It provides the user with the ability to explore the geographic distribution of devices or persons in the monitored room over a certain period of time. The location view can be found under the \'location\' tab in the analysis view. Below, we see a summary of the location heatmaps for the acelab experiment:</p><img class="doc-img img-responsive" src="assets/images/localisation_example.bda3b94b.png"><p>The heatmap is very similar to the actual positions of the participants in the acelab experiment during the experiment period. The upper part of the room (see figure above) was mainly used during the presentations at the meeting and hence the participants spent most of their time in that region. Occasionally, participants spread across the lower parts of the room during coffee breaks.</p><p>The use of WiFi probe requests for positioning has been used outdoors in many previous scientific works about WiFi sniffing and privacy. When it comes to indoors location, we come to the conclusion that computing locations via WiFi probe requests is only satisfying if the room / area that is monitored is rather large and the movements of the tracked devices are irregular. A small room introduces problems with accurracy, signal strength, and obstacles. If you have participants that are very uniform in movement the heatmaps will not notice smaller changes to the heatmap of the room.</p><h2><a name=tracking>Q2: Tracking</a></h2><p>For Q2, we wanted to find out whether it is possible to track patterns of presence regarding single MAC addresses or persons. This could for example be employed to track the presence of employees in an office.</p><p>Again, the definition of the session model proved to be very useful. Actually, the session map directly to the presence of said MAC address. Hence we can use a swimlane visualization method to display the session data appropriately. As an example, we show the tracking information about one of our project team members on a selected day during the project. The member had sniffing devices set up at home and at his university office.</p><img class="doc-img img-responsive" src="assets/images/tracking_example.67242bc5.png"><p>It is clearly visible when the member got up in the morning (shortly after 6 AM) and then spent the morning working from home. As you can see the system changes the color of the tracking bar depending on the location. Hence the bars/sessions starting at 1 PM to 2 PM are colored differently, because the tracked person came to the office then. In the evening, again the tracking target went home again, and was captured by the sniffing devices there.</p><p>This example shows that it is possible to track the day-cycle of a person using WiFi probe requests, given that the sniffing devices are placed appropriately and the person carries a WiFi-capable device all the time.</p><h2><a name=devices>Q3: Device Statistics</a></h2><p>By using the MAC address vendor prefixes defined by the IEEE (see <a href="">device worker</a>), we can map captured probe requests to a specific device vendor (e.g., Apple). This allows us to produce statistics about the vendor shares and segments in our data. The following figure illustrates the device vendor distribution as observed during the acelab experiment:</p><img class="doc-img img-responsive" src="assets/images/devices_acelab.cfb39750.png"><p>It is interesting to see that even a trivial things such as the vendor share of the devices that were sniffed can allow statements about the underlying persons or community. For instance, compare the chart above with the chart below, which displays the general vendor distribution over all in our data:</p><img class="doc-img img-responsive" src=assets/images/devices_overall.0fdeff93.png><p>The explanation of the differences may lie in the different kinds of communities. While the second pie chart is pretty similar to the general market share of mobile device and notebook vendors in our country (Switzerland), the first pie chart displaying data only for the acelab experiment shows much smaller shares for Apple and larger shares for some of the other vendors. We conclude the that audience at the acelab experiment, almost exclusively consisting of senior researchers and professors, apparently has an influence on their choice of devices. In contrast, we attribute the overall data to devices owned by students who seem to have a different taste in vendors.</p><h2><a name=discussion>Discussion</a></h2><p>In general, the observed results imply that adversaries employing WiFi sniffing can detect sensitive information about their target\'s location, daily behaviour, marketing information, or even things such as cultural background and social status. Hence, vendors of WiFi-enabled devices recently have started to acknowledge the threats of these kinds of privacy intrusions and they are trying to develop features that hamper collection of sensitive data.</p><p>One of the most employed techniques for this is the introduction of MAC address randomization when broadcasting probe requests. In general, this means that a device regularly changes its MAC address when probing for access points in order to avoid sending out a unique id by which it can be tracked and identified. Once the device is connected, it uses its real MAC address again. Initially, this approach seems to be a very solid protection against WiFi sniffing systems such as probr.</p><p>Through investigation of our data and review of related research in the field, we found out that it is indeed possible to still identify and fingerprint users even with randomized MAC addresses. The WiFi probe requests carry a sequence number in their header. Even if the MAC address changes randomly, it is possible to link probe requests to a certain device by matching sequence numbers. Another possibility emerges from the fact that devices send their preferred SSIDs in the probe requests. These can be used to fingerprint users even with MAC randomization in place. It is worth noting though that the major vendors have started to dramatically reduce the number of probe requests that contain SSID information in their latest systems, thus making fingerprinting and sniffing more difficult.</p></div></div></div><footer></footer>'),
a.put("components/directives/restApi.html","<h3 ng-if=name>{{name}}</h3><p><span class=label style=\"margin-right: 3px\" ng-class=\"{'label-primary': method == 'GET' || method == 'GET/LIST', 'label-info': method == 'POST' || method == 'PUT', 'label-danger': method == 'DELETE', 'active-label': method == displayedMethod }\" ng-repeat=\"method in methods\"><a ng-click=switch(method)>{{method}}</a></span> <small><span ng-if=description>{{description}}</span></small><pre><code><small>{{path | trimByMethod : displayedMethod}}</small></code></pre><pre ng-click=extendLimit() ng-show=payload[displayedMethod]><i class=\"fa fixed-caret\" ng-class=\"{'fa-caret-left': limit <= maxLimit, 'fa-caret-down': limit > maxLimit}\"></i><code><small>{{payload[displayedMethod] | prettyJSON | limitTo: limit}}</small></code></pre></p>"),a.put("components/footer/footer.html",'<div class=container><div class=row><div class=col-xs-2><a href=http://www.uzh.ch><img src=assets/images/uzh_logo.97f149bf.png style="float: left"></a></div><div class=col-xs-8><p class=text-center>probr | <a href=http://www.csg.uzh.ch>Communication Systems Group</a> at the <a href=http://www.uzh.ch>University of Zurich</a>, Switzerland</p></div><div class=col-xs-2><a href=http://www.csg.uzh.ch><img src=assets/images/csg_logo.ffc2e4f2.png style="float: right"></a></div></div></div>'),a.put("components/modal/modal.html",'<div class=modal-header><button ng-if=modal.dismissable type=button ng-click=$dismiss() class=close>&times;</button><h4 ng-if=modal.title ng-bind=modal.title class=modal-title></h4></div><div class=modal-body><p ng-if=modal.text ng-bind=modal.text></p><div ng-if=modal.html ng-bind-html=modal.html></div></div><div class=modal-footer><button ng-repeat="button in modal.buttons" ng-class=button.classes ng-click=button.click($event) ng-bind=button.text class=btn></button></div>'),a.put("components/navbar/navbar.html",'<div class="navbar navbar-inverse navbar-static-top" role=navigation ng-controller=NavbarCtrl><div class=container><div class=navbar-header><button class=navbar-toggle type=button ng-click="isCollapsed = !isCollapsed"><span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span></button> <a ui-sref=overview class=navbar-brand>probr</a></div><div collapse=isCollapsed class="navbar-collapse collapse" id=navbar-main><ul class="nav navbar-nav navbar-right"><li ng-class="{active: isActiveRoot(item.link)}" ng-repeat="item in menu" ng-attr-dropdown=isArray(item.link)><a ng-if=!isArray(item.link) ui-sref="{{ item.link }}">{{ item.title }}</a> <a ng-if=isArray(item.link) href=# dropdown-toggle>{{ item.title }}<b class=caret></b></a><ul ng-if=isArray(item.link) class=dropdown-menu><li ng-repeat="entry in item.link"><a ui-sref="{{ entry.link }}">{{ entry.name }}</a></li></ul></li><li ng-repeat-end><a href=http://github.com/probr><i class="fa fa-github"></i> Github</a></li></ul></div></div></div>')}]);