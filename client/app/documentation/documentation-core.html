<navbar></navbar>

<div class="row">

    <div class="container content">
        <div class="row">

            <div class="col-lg-3 side-nav-col">
                <section sticky-nav>
                    <h1>Contents</h1>
                    <ul class="nav nav-pills nav-stacked">

                        <li><a href="/#/docs/core#architecture">Architecture</a></li>
                        <li><a href="/#/docs/core#frontend">Front-End</a></li>

                        <h3>REST API</h3>
                        <li><a href="/#/docs/core#rest-frontend">Frontend API</a></li>
                        <li><a href="/#/docs/core#rest-device">Devices API</a></li>

                        <h3>Customizing</h3>
                        <li><a href="/#/docs/core#authentication">Authentication</a></li>
                        <li><a href="/#/docs/core#remote-execution">Remote execution</a></li>
                        <li><a href="/#/docs/core#handlers">Custom handlers</a></li>

                        <h3>Usage</h3>
                        <li><a href="/#/docs/core#add-device">Add device</a></li>
                        <li><a href="/#/docs/core#upload-capture">Upload capture</a></li>

                    </ul>
                </section>
            </div>

            <div class="col-lg-9">

                <h1>Documentation: probr-core</h1>

                <h2><a name="architecture">Architecture</a></h2>

                <p>
                    The image below shows the architecture of probr-core. Also, the used technologies are indicated in the respective
                    components.
                </p>

                <img class="doc-img img-responsive" src="assets/images/core.png">

                <p>
                    probr-core is built mainly in Python as a Django web application. It serves a frontend for the user written in
                    HTML 5 and AngularJS. Through the front end interface, the user can set up sniffing devices, enter sniffing commands,
                    upload existing pcap files containing packets and manage or check the status of the attached sniffing devices. The probr-core
                    Django application uses a PostgreSQL database internally as a backend to store and manage the different sniffing
                    devices, commands, statuses and uploads.
                </p>

                <p>
                    The Django back-end component provides the REST API endpoints for the front end, and
                    more importantly, also provides the REST API endpoints for the sniffing devices. Through those API endpoints the
                    devices receive their commands to execute (e.g. start sniffing, start uploading packets, or any other unix command) and
                    also report status data such as CPU and memory on a regular basis. The sniffing devices upload the sniffed data in pcap files
                    to the capture endpoint on the Django back-end. There, the system takes the pcap files and gives them to the Celery
                    worker handlers which entpack the pcap file into an appropriate structure for the respective storage. Out of the box,
                    probr-core has built-in handlers for MongoDB and InfluxDB, but it is designed to be easily extensible. Instructions on how to
                    write handlers for the data storage systems of your choosing can be found <a href="#/faq">here</a>.
                </p>

                <h2><a name="frontend">Front-end</a></h2>

                The web frontend is the main component in contact with the user. It is written entirely in HTML5 and JavaScript
                (with Angular).
                It provides the following views:

                <h3>Devices View</h3>
                <small>
                    <pre><code>/web/devices</code></pre>
                </small>
                <ul>
                    <li>Lets the user add new devices through the device wizard.</li>
                    <li>Lets the user see all registered devices and their status.</li>
                    <li>Lets the user open the device detail view of a device.</li>
                    <li>Allows deletion devices from the probr system.</li>
                    <li>Allows bulk-execution of a command on multiple devices at once</li>
                </ul>

                <h3>Devices Detail View</h3>
                <small>
                    <pre><code>/web/device/{device-uuid}</code></pre>
                </small>
                <ul>
                    <li>Lets the user to execute commands in the web terminal of a device</li>
                    <li>Allows to start sniffing and upload packets from predefined command templates</li>
                    <li>Allows to update the device client code for probr.</li>
                </ul>

                <h3>Captures View</h3>
                <small>
                    <pre><code>/web/captures</code></pre>
                </small>
                <ul>
                    <li>Allows to see the uploaded pcap files and download them</li>
                    <li>The user can upload pcap files by hand to integrate into the system.</li>
                </ul>

                <h2><a name="rest">REST API</a></h2>

                The diagram below shows the endpoints of the REST API available in probr-core:
                <br>

                <img class="doc-img img-responsive" src="assets/images/rest_core.png"/>

                <h3><a name="rest-frontend">Frontend API</a></h3>

                <p>
                    The endpoints starting with api/ are accessed by the probr-core web frontend. Those can only be accessed with a
                    valid
                    JSON WebToken (JWT). The JWT authentication is integrated with the Django user administration. For more info,
                    check out
                    the respective <a href="http://getblimp.github.io/django-rest-framework-jwt/">pip module</a>.
                </p>

                <h3>Devices</h3>
                <small>
                    <pre><code>GET: /api/device | [{device1},{device2},{device3}...]</code></pre>
                    <pre><code>POST: /api/device | Payload: {JSON-Device}</code></pre>
                    <pre><code>GET: /api/device/{device-uuid} | {device}</code></pre>
                    <pre><code>PUT: /api/device/{device-uuid} | Payload: {JSON-Device}</code></pre>
                    <pre><code>DELETE: /api/device/{device-uuid}</code></pre>
                </small>

                <h3>Statuses</h3>
                <small>
                    <pre><code>GET: /api/statuses/ | [{status1},{status2},{status3}...]</code></pre>
                </small>

                <h3>Commands</h3>
                <small>
                    <pre><code>GET: /api/commands/ | [{command1},{command2},{command3}...]</code></pre>
                    <pre><code>POST: /api/commands/ | Payload: {JSON-Status}</code></pre>
                    <pre><code>GET: /api/commands/{command-uuid} | {command}</code></pre>
                    <pre><code>PUT: /api/commands/{command-uuid} | Payload: {JSON-Status}</code></pre>
                </small>

                <h3>Command Templates</h3>
                <small>
                    <pre><code>GET: /api/commandtemplates/ | [{commandtemplate1},{commandtemplate2},{commandtemplate3}...]</code></pre>
                    <pre><code>POST: /api/commandtemplates/ | Payload: {JSON-CommandTemplate}</code></pre>
                    <pre><code>GET: /api/commandtemplates/{commandtemplates-uuid} | {commandtemplate}</code></pre>
                    <pre><code>PUT: /api/commandtemplates/{commandtemplates-uuid} | Payload: {JSON-CommandTemplate}</code></pre>
                </small>

                <h3><a name="rest-devices">Devices API</a></h3>

                <p>
                    The API endpoints starting with api-device/ are the ones that are accessed solely by the sniffing devices. Those
                    can only be accessed with a valid api-key. A sniffing device receives an api-key on set-up through the device
                    wizard in the web frontend. Setting up a device is only possible if the user is logged in via Django user administration/JWTAuth. The api-key also identifies the device
                    that sends the requests.
                </p>

                <h3>Captures</h3>
                <small>
                    <pre><code>POST: /api-device/captures | Payload: Capture</code></pre>
                </small>

                <h3>Statuses</h3>
                <small>
                    <pre><code>GET: /api-device/statuses/ | [{statuses1},{statuses2},{statuses3}...]</code></pre>
                    <pre><code>POST: /api-device/statuses/ | Payload: {JSON-Status}</code></pre>
                </small>

                <h3>Commands</h3>
                <small>
                    <pre><code>GET: /api-device/commands/ | [{commands1},{commands2},{commands3}...]</code></pre>
                    <pre><code>POST: /api-device/commands/ | Payload: {JSON-Command}</code></pre>
                    <pre><code>PUT: /api-device/commands/{command-uuid} | Payload: {JSON-Command}</code></pre>
                </small>

                <h2><a name="authentication">Authentication</a></h2>

                <h2><a name="remote-execution">Remote command execution</a></h2>

                <h2><a name="handlers">Writing custom handlers</a></h2>

                <h2><a name="usage">Usage samples</a></h2>

                <p>
                    See <a ui-sref="usage-core">Usage-Core</a> for more details;
                </p>

            </div>

        </div>

    </div>
</div>

</div>
<footer></footer>
